{"/home/travis/build/npmtest/node-npmtest-wordpos/test.js":"/* istanbul instrument in package npmtest_wordpos */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-wordpos/lib.npmtest_wordpos.js":"/* istanbul instrument in package npmtest_wordpos */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_wordpos = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_wordpos = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-wordpos/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-wordpos && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_wordpos */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_wordpos\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_wordpos.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_wordpos.rollup.js'] =\n            local.assetsDict['/assets.npmtest_wordpos.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_wordpos.__dirname + '/lib.npmtest_wordpos.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-wordpos/node_modules/wordpos/src/wordpos.js":"/*!\r\n* wordpos.js\r\n*\r\n*    Node.js part-of-speech utilities using WordNet database.\r\n*\r\n* Copyright (c) 2012-2016 mooster@42at.com\r\n* https://github.com/moos/wordpos\r\n*\r\n* Released under MIT license\r\n*/\r\n\r\nvar _ = require('underscore')._,\r\n  util = require('util'),\r\n  stopwords = require('../lib/natural/util/stopwords').words,\r\n  stopwordsStr = makeStopwordString(stopwords),\r\n  WNdb = require('wordnet-db'),\r\n  DataFile = require('./dataFile'),\r\n  IndexFile = require('./indexFile');\r\n\r\n\r\nfunction normalize(word) {\r\n  return word.toLowerCase().replace(/\\s+/g, '_');\r\n}\r\n\r\nfunction makeStopwordString(stopwords) {\r\n  return ' '+ stopwords.join(' ') +' ';\r\n}\r\n\r\nfunction isStopword(stopwords, word) {\r\n  return stopwords.indexOf(' '+word+' ') >= 0;\r\n}\r\n\r\nfunction tokenizer(str) {\r\n  return str.split(/\\W+/); //_.without(results,'',' ')\r\n}\r\n\r\nfunction prepText(text) {\r\n  if (_.isArray(text)) return text;\r\n  var deduped = _.uniq(tokenizer(text));\r\n  if (!this.options.stopwords) return deduped;\r\n  return _.reject(deduped, _.bind(isStopword, null,\r\n    _.isString(this.options.stopwords) ? this.options.stopwords : stopwordsStr\r\n  ));\r\n}\r\n\r\n/**\r\n * factory for main lookup function\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {Function} - lookup function bound to POS\r\n */\r\nfunction lookup(pos) {\r\n  return function(word, callback) {\r\n    var profile = this.options.profile,\r\n      start = profile && new Date(),\r\n      files = this.getFilesFor(pos),\r\n      args = [];\r\n\r\n    word = normalize(word);\r\n\r\n    // lookup index\r\n    return files.index.lookup(word)\r\n      .then(function(result) {\r\n        if (result) {\r\n          // lookup data\r\n          return files.data.lookup(result.synsetOffset).then(done);\r\n        } else {\r\n          // not found in index\r\n          return done([]);\r\n        }\r\n      })\r\n      .catch(done);\r\n\r\n    function done(results) {\r\n      if (results instanceof Error) {\r\n        args.push([], word);\r\n      } else {\r\n        args.push(results, word);\r\n      }\r\n      //console.log(3333, args)\r\n      profile && args.push(new Date() - start);\r\n      nextTick(callback, args);\r\n      return results;\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * isX() factory function\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {Function}\r\n */\r\nfunction is(pos){\r\n  return function(word, callback, _noprofile) {\r\n    // disable profiling when isX() used internally\r\n    var profile = this.options.profile && !_noprofile,\r\n      start = profile && new Date(),\r\n      args = [],\r\n      index = this.getFilesFor(pos).index;\r\n    word = normalize(word);\r\n\r\n    return index\r\n      .lookup(word)\r\n      .then(function(record) {\r\n        var result = !!record;\r\n        args.push(result, word);\r\n        profile && args.push(new Date() - start);\r\n        nextTick(callback, args);\r\n        return result;\r\n      });\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * getX() factory function\r\n *\r\n * @param isFn {function} - an isX() function\r\n * @returns {Function}\r\n */\r\nfunction get(isFn) {\r\n  return function(text, callback, _noprofile) {\r\n    var profile = this.options.profile && !_noprofile,\r\n      start = profile && new Date(),\r\n      words = this.parse(text),\r\n      results = [],\r\n      self = this;\r\n\r\n    //if (!n) return (process.nextTick(done),0);\r\n    return Promise\r\n      .all(words.map(exec))\r\n      .then(done);\r\n\r\n    function exec(word) {\r\n      return self[isFn]\r\n        .call(self, word, null, /*_noprofile*/ true)\r\n        .then(function collect(result) {\r\n          result && results.push(word);\r\n        });\r\n    }\r\n\r\n    function done(){\r\n      var args = [results];\r\n      profile && args.push(new Date() - start);\r\n      nextTick(callback, args);\r\n      return results;\r\n    }\r\n  };\r\n}\r\n\r\n// setImmediate executes callback AFTER promise handlers.\r\n// Without it, exceptions in callback may be caught by Promise.\r\nfunction nextTick(fn, args) {\r\n  if (fn) {\r\n    fn.apply(null, args);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @class WordPOS\r\n * @param options {object} -- @see WordPOS.defaults\r\n * @constructor\r\n */\r\nvar WordPOS = function(options) {\r\n  var dictPath;\r\n\r\n  this.options = _.defaults({}, _.isObject(options) && options || {}, {\r\n    dictPath: WNdb.path\r\n  }, WordPOS.defaults);\r\n\r\n  dictPath = this.options.dictPath;\r\n\r\n  this.nounIndex = new IndexFile(dictPath, 'noun');\r\n  this.verbIndex = new IndexFile(dictPath, 'verb');\r\n  this.adjIndex = new IndexFile(dictPath, 'adj');\r\n  this.advIndex = new IndexFile(dictPath, 'adv');\r\n\r\n  this.nounData = new DataFile(dictPath, 'noun');\r\n  this.verbData = new DataFile(dictPath, 'verb');\r\n  this.adjData = new DataFile(dictPath, 'adj');\r\n  this.advData = new DataFile(dictPath, 'adv');\r\n\r\n  // define randX() functions\r\n  require('./rand').init(this);\r\n\r\n  if (_.isArray(this.options.stopwords)) {\r\n    this.options.stopwords = makeStopwordString(this.options.stopwords);\r\n  }\r\n};\r\n\r\n\r\nWordPOS.defaults = {\r\n  /**\r\n   * path to WordNet data (override only if not using wordnet-db)\r\n   */\r\n  dictPath: '',\r\n\r\n  /**\r\n   * enable profiling, time in msec returned as second argument in callback\r\n   */\r\n  profile: false,\r\n\r\n  /**\r\n   * if true, exclude standard stopwords.\r\n   * if array, stopwords to exclude, eg, ['all','of','this',...]\r\n   * if false, do not filter any stopwords.\r\n   */\r\n  stopwords: true\r\n};\r\n\r\nvar wordposProto = WordPOS.prototype;\r\n\r\n/**\r\n * lookup a word in all indexes\r\n *\r\n * @param word {string} - search word\r\n * @param callback {Function} (optional) - callback with (results, word) signature\r\n * @returns {Promise}\r\n */\r\nwordposProto.lookup = function(word, callback) {\r\n  var self = this,\r\n    results = [],\r\n    profile = this.options.profile,\r\n    start = profile && new Date(),\r\n    methods = ['lookupAdverb', 'lookupAdjective', 'lookupVerb', 'lookupNoun'];\r\n\r\n  return Promise\r\n    .all(methods.map(exec))\r\n    .then(done)\r\n    .catch(error);\r\n\r\n  function exec(method) {\r\n    return self[ method ]\r\n      .call(self, word)\r\n      .then(function collect(result){\r\n        results = results.concat(result);\r\n      });\r\n  }\r\n\r\n  function done() {\r\n    var args = [results, word];\r\n    profile && args.push(new Date() - start);\r\n    nextTick(callback, args);\r\n    return results;\r\n  }\r\n\r\n  function error(err) {\r\n    nextTick(callback, [[], word]);\r\n    throw err;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * getPOS() - Find all POS for all words in given string\r\n *\r\n * @param text {string} - words to lookup for POS\r\n * @param callback {function} (optional) - receives object with words broken into POS or 'rest', ie,\r\n * \t    Object: {nouns:[], verbs:[], adjectives:[], adverbs:[], rest:[]}\r\n * @return Promise - resolve function receives data object\r\n */\r\nwordposProto.getPOS = function(text, callback) {\r\n  var self = this,\r\n    data = {nouns:[], verbs:[], adjectives:[], adverbs:[], rest:[]},\r\n    profile = this.options.profile,\r\n    start = profile && new Date(),\r\n    words = this.parse(text),\r\n    methods = ['getAdverbs', 'getAdjectives', 'getVerbs', 'getNouns'];\r\n\r\n  return Promise\r\n    .all(methods.map(exec))\r\n    .then(done)\r\n    .catch(error);\r\n\r\n  function exec(method) {\r\n    return self[ method ]\r\n      .call(self, text, null, true)\r\n      .then(function collect(results) {\r\n        // getAdjectives --> adjectives\r\n        var pos = method.replace('get','').toLowerCase();\r\n        data[ pos ] =  results;\r\n      });\r\n  }\r\n\r\n  function done() {\r\n    var matches = _(data).chain()\r\n      .values()\r\n      .flatten()\r\n      .uniq()\r\n      .value(),\r\n      args = [data];\r\n\r\n    data.rest =  _(words).difference(matches);\r\n\r\n    profile && args.push(new Date() - start);\r\n    nextTick(callback, args);\r\n    return data;\r\n  }\r\n\r\n  function error(err) {\r\n    nextTick(callback, []);\r\n    throw err;\r\n  }\r\n};\r\n\r\n/**\r\n * get index and data files for given pos\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {object} - keys {index, data}\r\n */\r\nwordposProto.getFilesFor = function (pos) {\r\n  switch(pos) {\r\n    case 'n':\r\n      return {index: this.nounIndex, data: this.nounData};\r\n    case 'v':\r\n      return {index: this.verbIndex, data: this.verbData};\r\n    case 'a': case 's':\r\n    return {index: this.adjIndex, data: this.adjData};\r\n    case 'r':\r\n      return {index: this.advIndex, data: this.advData};\r\n  }\r\n  return {};\r\n};\r\n\r\n\r\n/**\r\n * lookupX() - Lookup word definition if already know POS\r\n * @see lookup\r\n */\r\nwordposProto.lookupAdjective = lookup('a');\r\nwordposProto.lookupAdverb = lookup('r');\r\nwordposProto.lookupNoun = lookup('n');\r\nwordposProto.lookupVerb = lookup('v');\r\n\r\n/**\r\n * isX() - Test if word is given POS\r\n * @see is\r\n */\r\nwordposProto.isAdjective = is('a');\r\nwordposProto.isAdverb = is('r');\r\nwordposProto.isNoun = is('n');\r\nwordposProto.isVerb = is('v');\r\n\r\n/**\r\n * getX() - Find all words in string that are given POS\r\n * @see get\r\n */\r\nwordposProto.getAdjectives = get('isAdjective');\r\nwordposProto.getAdverbs = get('isAdverb');\r\nwordposProto.getNouns = get('isNoun');\r\nwordposProto.getVerbs = get('isVerb');\r\n\r\n/**\r\n * parse - get deduped, less stopwords\r\n *\r\n * @param text {string|array} - string of words to parse.  If array is given, it is left in tact.\r\n * @returns {array}\r\n */\r\nwordposProto.parse = prepText;\r\n\r\n\r\n/**\r\n * seek - get record at offset for pos\r\n *\r\n * @param offset {number} - synset offset\r\n * @param pos {string} - POS a/r/n/v\r\n * @param callback {function} - optional callback\r\n * @returns Promise\r\n */\r\nwordposProto.seek = function(offset, pos, callback){\r\n  offset = Number(offset);\r\n  if (_.isNaN(offset) || offset <= 0) return error('offset must be valid positive number.');\r\n\r\n  var data = this.getFilesFor(pos).data;\r\n  if (!data) return error('Incorrect POS - 2nd argument must be a, r, n or v.');\r\n\r\n  return data.lookup(offset, callback);\r\n\r\n  function error(msg) {\r\n    var err = new Error(msg);\r\n    callback && callback(err, {});\r\n    return Promise.reject(err);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * access to WordNet DB\r\n * @type {object}\r\n */\r\nWordPOS.WNdb = WNdb;\r\n\r\n/**\r\n * access to stopwords\r\n * @type {Array}\r\n */\r\nWordPOS.stopwords = stopwords;\r\n\r\n\r\nmodule.exports = WordPOS;\r\n","/home/travis/build/npmtest/node-npmtest-wordpos/node_modules/wordpos/lib/natural/util/stopwords.js":"/*\nCopyright (c) 2011, Chris Umbel\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// a list of commonly used words that have little meaning and can be excluded\n// from analysis.\nvar words = [\n    'about', 'after', 'all', 'also', 'am', 'an', 'and', 'another', 'any', 'are', 'as', 'at', 'be',\n    'because', 'been', 'before', 'being', 'between', 'both', 'but', 'by', 'came', 'can',\n    'come', 'could', 'did', 'do', 'each', 'for', 'from', 'get', 'got', 'has', 'had',\n    'he', 'have', 'her', 'here', 'him', 'himself', 'his', 'how', 'if', 'in', 'into',\n    'is', 'it', 'like', 'make', 'many', 'me', 'might', 'more', 'most', 'much', 'must',\n    'my', 'never', 'now', 'of', 'on', 'only', 'or', 'other', 'our', 'out', 'over',\n    'said', 'same', 'see', 'should', 'since', 'some', 'still', 'such', 'take', 'than',\n    'that', 'the', 'their', 'them', 'then', 'there', 'these', 'they', 'this', 'those',\n    'through', 'to', 'too', 'under', 'up', 'very', 'was', 'way', 'we', 'well', 'were',\n    'what', 'where', 'which', 'while', 'who', 'with', 'would', 'you', 'your',\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '$', '1',\n    '2', '3', '4', '5', '6', '7', '8', '9', '0', '_'];\n    \n// tell the world about the noise words.    \nexports.words = words;\n","/home/travis/build/npmtest/node-npmtest-wordpos/node_modules/wordpos/src/dataFile.js":"/*!\n * dataFile.js\n *\n * Copyright (c) 2012-2016 mooster@42at.com\n * https://github.com/moos/wordpos\n *\n * Portions: Copyright (c) 2011, Chris Umbel\n *\n * Released under MIT license\n */\n\nvar fs = require('fs'),\n  path = require('path'),\n  _ = require('underscore');\n\n/**\n * sanity check read data - line must start with zero-padded location\n *\n * @param line {string} - line data read\n * @return {boolean} true if line data is good\n */\nfunction dataCheck(line, location) {\n  var pad = '00000000', // 8 zeros\n    padded = String(pad + location).slice( - pad.length);\n  return line.indexOf(padded) === 0;\n}\n\n/**\n * parse a single data file line, returning data object\n *\n * @param line {string} - a single line from WordNet data file\n * @returns {object}\n *\n * Credit for this routine to https://github.com/NaturalNode/natural\n */\nfunction lineDataToJSON(line, location) {\n  if (!dataCheck(line, location)) return new Error('Bad data at location ' + location);\n\n  var data = line.split('| '),\n    tokens = data[0].split(/\\s+/),\n    ptrs = [],\n    wCnt = parseInt(tokens[3], 16),\n    synonyms = [],\n    i;\n\n  for(i = 0; i < wCnt; i++) {\n    synonyms.push(tokens[4 + i * 2]);\n  }\n\n  var ptrOffset = (wCnt - 1) * 2 + 6;\n  for(i = 0; i < parseInt(tokens[ptrOffset], 10); i++) {\n    ptrs.push({\n      pointerSymbol: tokens[ptrOffset + 1 + i * 4],\n      synsetOffset: parseInt(tokens[ptrOffset + 2 + i * 4], 10),\n      pos: tokens[ptrOffset + 3 + i * 4],\n      sourceTarget: tokens[ptrOffset + 4 + i * 4]\n    });\n  }\n\n  // break \"gloss\" into definition vs. examples\n  var glossArray = data[1].split(\"; \");\n  var definition = glossArray[0];\n  var examples = glossArray.slice(1);\n  var lexFilenum = parseInt(tokens[1], 10);\n\n  for (var k = 0; k < examples.length; k++) {\n    examples[k] = examples[k].replace(/\\\"/g,'').replace(/\\s\\s+/g,'');\n  }\n\n  return {\n    synsetOffset: parseInt(tokens[0], 10),\n    lexFilenum: lexFilenum,\n    lexName: DataFile.LEX_NAMES[ lexFilenum ],\n    pos: tokens[2],\n    wCnt: wCnt,\n    lemma: tokens[4],\n    synonyms: synonyms,\n    lexId: tokens[5],\n    ptrs: ptrs,\n    gloss: data[1],\n    def: definition,\n    exp: examples\n  };\n}\n\n/**\n * read data file at location (bound to a data file).\n * Reads nominal length and checks for EOL.  Continue reading until EOL.\n *\n * @param location {Number} - seek location\n * @param callback {function} - callback function\n */\nfunction readLocation(location, callback) {\n  //console.log('## read location ', this.fileName, location);\n  var\n    file = this,\n    str = '',\n    len = file.nominalLineLength,\n    buffer = new Buffer(len);   // TODO @deprecated as of node 6.0\n\n  readChunk(location, function(err, count) {\n    if (err) {\n      //console.log(err);\n      callback(err);\n      return;\n    }\n    //console.log('  read %d bytes at <%d>', count, location);\n    callback(null, lineDataToJSON(str, location));\n  });\n\n  function readChunk(pos, cb) {\n    var nonDataErr = new Error('no data at offset ' + pos);\n\n    fs.read(file.fd, buffer, 0, len, pos, function (err, count) {\n      if (!count) return cb(nonDataErr, count);\n\n      str += buffer.toString('ascii');\n      var eol = str.indexOf('\\n');\n      //console.log('  -- read %d bytes at <%d>', count, pos, eol);\n      if (count && eol === -1 && len < file.maxLineLength) {\n        // continue reading\n        return readChunk(pos + count, cb);\n      }\n\n      str = str.substr(0, eol);\n      if (str === '' && !err) err = nonDataErr;\n      cb(err, count);\n    });\n  }\n}\n\n/**\n * main lookup function\n *\n * @param offsets {array} - array of offsets to lookup (obtained from index.find())\n * @param callback{function} (optional) - callback function\n * @returns {Promise}\n */\nfunction lookup(offsets, callback) {\n  var results = [],\n    self = this,\n    single = !_.isArray(offsets);\n\n  if (single) offsets = [offsets];\n  return new Promise(function(resolve, reject) {\n    offsets\n      .map(function (offset) {\n        return _.partial(readLocation.bind(self), offset);\n      })\n      .map(promisifyInto(results))\n      .reduce(serialize, openFile())\n      .then(done)\n      .catch(done);\n\n    function done(lastResult) {\n      closeFile();\n      if (lastResult instanceof Error) {\n        callback && callback(lastResult, single ? {} :[]);\n        reject(lastResult);\n      } else {\n        if (single) results = results[0];\n        callback && callback(null, results);\n        resolve(results);\n      }\n    }\n  });\n\n  function serialize(prev, next) {\n    return prev.then(next);\n  }\n\n  function openFile() {\n    if (!self.fd) {\n      // console.log(' ... opening', self.filePath);\n      self.fd = fs.openSync(self.filePath, 'r');\n    }\n    // ref count so we know when to close the main index file\n    ++self.refcount;\n    return Promise.resolve();\n  }\n\n  function closeFile() {\n    if (--self.refcount === 0) {\n      // console.log(' ... closing', self.filePath);\n      fs.closeSync(self.fd);\n      self.fd = null;\n    }\n    return Promise.resolve();\n  }\n}\n\n/**\n * turn ordinary function into a promising one!\n *\n * @param collect {Array} - used to collect results\n * @returns {Function}\n */\nfunction promisifyInto(collect) {\n  return function(fn) {\n    return function() {\n      return new Promise(function (resolve, reject) {\n        fn(function (error, result) {   // Note: callback signature!\n          if (error) {\n            reject(error);\n          }\n          else {\n            collect && collect.push(result);\n            resolve(result);\n          }\n        });\n      });\n    };\n  }\n}\n\n\n/**\n * DataFile class\n *\n * @param dictPath {string} - path to dict folder\n * @param name {string} - POS name\n * @constructor\n */\nvar DataFile = function(dictPath, name) {\n  this.dictPath = dictPath;\n  this.fileName = 'data.' + name;\n  this.filePath = path.join(this.dictPath, this.fileName);\n\n  this.maxLineLength = DataFile.MAX_LINE_LENGTH[ name ];\n  this.nominalLineLength = MAX_SINGLE_READ_LENGTH;\n  this.refcount = 0;\n};\n\n/**\n * maximum read length at a time\n * @type {Number}\n */\nvar MAX_SINGLE_READ_LENGTH = 512;\n\n/**\n * lookup\n */\nDataFile.prototype.lookup = lookup;\n\n\n/**\n * maximum line length in each data file - used to optimize reads\n *\n * wc -L data.adv as of v3.1\n */\nDataFile.MAX_LINE_LENGTH = {\n  noun: 12972,\n  verb: 7713,\n  adj: 2794,\n  adv: 638\n};\n\n/**\n * map of lexFilenum to lex names\n *\n * @see https://wordnet.princeton.edu/wordnet/man/lexnames.5WN.html\n * @type {string[]}\n */\nDataFile.LEX_NAMES = [\n  'adj.all',\n  'adj.pert',\n  'adv.all',\n  'noun.Tops',\n  'noun.act',\n  'noun.animal',\n  'noun.artifact',\n  'noun.attribute',\n  'noun.body',\n  'noun.cognition',\n  'noun.communication',\n  'noun.event',\n  'noun.feeling',\n  'noun.food',\n  'noun.group',\n  'noun.location',\n  'noun.motive',\n  'noun.object',\n  'noun.person',\n  'noun.phenomenon',\n  'noun.plant',\n  'noun.possession',\n  'noun.process',\n  'noun.quantity',\n  'noun.relation',\n  'noun.shape',\n  'noun.state',\n  'noun.substance',\n  'noun.time',\n  'verb.body',\n  'verb.change',\n  'verb.cognition',\n  'verb.communication',\n  'verb.competition',\n  'verb.consumption',\n  'verb.contact',\n  'verb.creation',\n  'verb.emotion',\n  'verb.motion',\n  'verb.perception',\n  'verb.possession',\n  'verb.social',\n  'verb.stative',\n  'verb.weather',\n  'adj.ppl'\n];\n\nmodule.exports = DataFile;\n","/home/travis/build/npmtest/node-npmtest-wordpos/node_modules/wordpos/src/indexFile.js":"/*!\r\n * indexFile.js\r\n *\r\n * \t\timplements fast index lookup of WordNet's index files\r\n *\r\n * Copyright (c) 2012-2016 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Portions: Copyright (c) 2011, Chris Umbel\r\n *\r\n * Released under MIT license\r\n */\r\n\r\nvar _ = require('underscore')._,\r\n  util = require('util'),\r\n  path = require('path'),\r\n  fs = require('fs'),\r\n  piper = require('./piper'),\r\n  KEY_LENGTH = 3;\r\n\r\n\r\n/**\r\n * load fast index bucket data\r\n *\r\n * @param dir {string} - dir path of index files\r\n * @param name {string} - name of index file, eg, 'index.verb'\r\n * @returns {Object} - fast index data object\r\n */\r\nfunction loadFastIndex(dir, name) {\r\n  var jsonFile = path.join(dir, 'fast-' + name + '.json'),\r\n    data = null;\r\n  try{\r\n    data = JSON.parse( fs.readFileSync(jsonFile,'utf8') );\r\n    //console.log('loaded %d buckets for %s', data.stats.buckets, data.name);\r\n  } catch(e) {\r\n    console.error('Error with fast index file. Try reinstalling from npm!');\r\n    throw e;\r\n  }\r\n  return data;\r\n}\r\n\r\n/**\r\n * read index file using fast index data at key\r\n *\r\n * @param key {string} - 3-char key into fast index\r\n * @param index {object} - index file object\r\n * @param callback {function} - function receives buffer of data read\r\n * @returns none\r\n */\r\nfunction readIndexForKey(key, index, callback) {\r\n  var data = index.fastIndex,\r\n    offset = data.offsets[key][0],\r\n    nextKey = data.offsets[key][1],\r\n    nextOffset = data.offsets[nextKey][0],\r\n    len = nextOffset - offset - 1,\r\n    buffer = new Buffer(len);\r\n\r\n  fs.read(index.fd, buffer, 0, len, offset, function(err, count){\r\n     if (err) return console.log(err);\r\n     //console.log('  read %d bytes for <%s>', count, key);\r\n     callback(buffer);\r\n  });\r\n}\r\n\r\n\r\n/**\r\n * read index file using fast index data at keyStart to keyEnd (inclusive)\r\n *\r\n * @param keyStart {string} - 3-char key into fast index to begin at\r\n * @param keyEnd {string|null} - 3-char key into fast index to end at.  If null, reads to next key.\r\n * @param index {object} - index file object\r\n * @param callback - function receives buffer of data read\r\n * @returns none\r\n */\r\nfunction readIndexBetweenKeys(keyStart, keyEnd, index, callback) {\r\n  var data = index.fastIndex,\r\n    offset = data.offsets[keyStart][0],\r\n    end = keyEnd || keyStart,\r\n    nextKey = data.offsets[end][1],\r\n    nextOffset = data.offsets[nextKey][0],\r\n    len = nextOffset - offset - 1,\r\n    buffer = new Buffer(len);\r\n\r\n  //console.log('### readIndexBetweenKeys', keyStart, keyEnd, nextKey, len)\r\n  fs.read(index.fd, buffer, 0, len, offset, function(err, count){\r\n     if (err) return console.log(err);\r\n     // console.log('  read %d bytes for <%s>', count, keyStart);\r\n     callback(buffer);\r\n  });\r\n}\r\n\r\n/**\r\n * find a search term in an index file (using fast index)\r\n *\r\n * Calls to same bucket are queued for callback using the piper.\r\n *\r\n * @param search {string} - word to search for\r\n * @param callback {function} - callback receives found line and tokens\r\n * @returns none\r\n */\r\nfunction find(search, callback) {\r\n  var self = this,\r\n    data = this.fastIndex,\r\n    readCallbacks = this.callbackQueue,\r\n    miss = {status: 'miss'};\r\n\r\n  var key = search.slice(0, KEY_LENGTH);\r\n  if (!(key in data.offsets)) return process.nextTick(function(){ callback(miss) });\r\n\r\n  // prepare the piper\r\n  var task = 'find:' + key,\r\n    args = [key, this],\r\n    context = [search, callback]; // last arg MUST be callback\r\n\r\n  // pay the piper\r\n  this.piper(task, readIndexForKey, args, context, collector);\r\n\r\n  function collector(_key, index, search, callback, buffer){\r\n    var lines = buffer.toString().split('\\n'),\r\n      keys = lines.map(function(line){\r\n        return line.substring(0,line.indexOf(' '));\r\n      }),\r\n      ind = _.indexOf(keys, search, /*isSorted*/ true);\t// binary search!\r\n\r\n    //console.log(' %s is %d', search, ind);\r\n    if (ind === -1) return callback(miss);\r\n\r\n    var tokens = lines[ind].split(/\\s+/),\r\n      key = tokens[0],\r\n      result = {status: 'hit', key: key, 'line': lines[ind], tokens: tokens};\r\n\r\n    callback(result);\r\n  }\r\n}\r\n\r\n/**\r\n * find a word and prepare its lexical record\r\n *\r\n * @param word {string} - search word\r\n * @param callback {function} - callback function receives result\r\n * @returns none\r\n *\r\n * Credit for this routine to https://github.com/NaturalNode/natural\r\n */\r\nfunction lookup(word, callback) {\r\n  var self = this;\r\n\r\n  return new Promise(function(resolve, reject){\r\n    self.find(word, function (record) {\r\n      var indexRecord = null,\r\n        i;\r\n\r\n      if (record.status == 'hit') {\r\n        var ptrs = [], offsets = [];\r\n\r\n        for (i = 0; i < parseInt(record.tokens[3]); i++)\r\n          ptrs.push(record.tokens[i]);\r\n\r\n        for (i = 0; i < parseInt(record.tokens[2]); i++)\r\n          offsets.push(parseInt(record.tokens[ptrs.length + 6 + i], 10));\r\n\r\n        indexRecord = {\r\n          lemma       : record.tokens[0],\r\n          pos         : record.tokens[1],\r\n          ptrSymbol   : ptrs,\r\n          senseCnt    : parseInt(record.tokens[ptrs.length + 4], 10),\r\n          tagsenseCnt : parseInt(record.tokens[ptrs.length + 5], 10),\r\n          synsetOffset: offsets\r\n        };\r\n      }\r\n\r\n      callback && callback(indexRecord);\r\n      resolve(indexRecord);\r\n    });\r\n  });\r\n}\r\n\r\n\r\n/**\r\n * loads fast index data and return fast index find function\r\n *\r\n * @param index {object} - the IndexFile instance\r\n */\r\nfunction initIndex(index){\r\n  var key = index.filePath,\r\n    data;\r\n\r\n  if (!(key in cache)) {\r\n    data = loadFastIndex(index.dictPath, index.fileName);\r\n    cache[key] = data;\r\n  }\r\n\r\n  // if no fast index data was found or was corrupt, throw\r\n  if (!cache[key]) throw new Error('Unable to load fastIndex file: ' + index.filePath);\r\n\r\n  index.fastIndex = cache[key];\r\n  index.fastIndex.indexKeys = Object.keys(index.fastIndex.offsets);\r\n  index.fastIndex.trie = null;  // calc on demand\r\n\r\n  index.refcount = 0;\r\n  index.callbackQueue = {};\r\n  index.piper = _.bind(piper, index);\r\n}\r\n\r\n/**\r\n * IndexFile class\r\n *\r\n * @param dictPath {string} - WordNet db dict path\r\n * @param name {string} - name of index: noun, verb, adj, adv\r\n * @constructor\r\n */\r\nvar IndexFile = function(dictPath, name) {\r\n  this.dictPath = dictPath;\r\n  this.fileName = 'index.' + name;\r\n  this.filePath = path.join(this.dictPath, this.fileName);\r\n  initIndex(this);\r\n};\r\n\r\nIndexFile.prototype.lookup = lookup;\r\nIndexFile.prototype.find = find;\r\n\r\n/**\r\n * export static method\r\n * @type {readIndexBetweenKeys}\r\n */\r\nIndexFile.readIndexBetweenKeys = readIndexBetweenKeys;\r\n\r\n/**\r\n * cache of fast index data across instances of WordPOS class\r\n *\r\n * @type {object}\r\n */\r\nvar cache = {};\r\n\r\n\r\n\r\nmodule.exports = IndexFile;\r\n","/home/travis/build/npmtest/node-npmtest-wordpos/node_modules/wordpos/src/piper.js":"/*!\r\n * piper.js\r\n *\r\n *     executes multiple async i/o tasks and pools similar callbacks,\r\n *     calling i/o open/close when all incoming tasks are done.\r\n *\r\n * Copyright (c) 2012-2016 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Released under MIT license\r\n */\r\n\r\nvar _ = require('underscore')._,\r\n  util = require('util'),\r\n  fs = require('fs');\r\n\r\n/**\r\n * run single 'task' method sharing callbacks.  Method MUST take callback as LAST arg.\r\n * piper is bound to an IndexFile.\r\n *\r\n * @param task {string} - task name unique to method!\r\n * @param method {function} - method to execute, gets (args, ... , callback)\r\n * @param args {Array} - args to pass to method\r\n * @param context {object} - other params to remember and sent to callback\r\n * @param callback {function} - result callback\r\n */\r\nfunction piper(task, method, args, context, callback){\r\n  var readCallbacks = this.callbackQueue,\r\n    memoArgs = _.rest(arguments, 2),\r\n    wrappedCallback;\r\n\r\n   //console.log('piper', task, [method]);\r\n\r\n  // queue up if already reading file for this task\r\n  if (task in readCallbacks){\r\n    readCallbacks[task].push(memoArgs);\r\n    return;\r\n  }\r\n  readCallbacks[task] = [memoArgs];\r\n\r\n  if (!this.fd) {\r\n    //console.log(' ... opening', this.filePath);\r\n    this.fd = fs.openSync(this.filePath, 'r');\r\n  }\r\n\r\n  // ref count so we know when to close the main index file\r\n  ++this.refcount;\r\n\r\n  wrappedCallback = _.partial(piper.wrapper, this, task);\r\n\r\n  // call method -- replace original callback (last arg) with wrapped one\r\n  method.apply(null, [].concat( args, wrappedCallback ));\r\n}\r\n\r\n// result is the *same* for same task\r\npiper.wrapper = function(self, task /*, result...*/){\r\n  var readCallbacks = self.callbackQueue,\r\n    result = _.rest(arguments, 2),\r\n    callback, args;\r\n\r\n  // live access callbacks cache in case nested cb's\r\n  // add to the array.\r\n  while (args = readCallbacks[task].shift()) {\r\n    callback = args.pop(); // last arg MUST be callback\r\n\r\n//    console.log('>>>> pper wrapper', self.fastIndex.name, task, result.toString())\r\n    callback.apply(null, [].concat(_.flatten(args, /*shallow*/true), result));\r\n  }\r\n\r\n  // now done - delete cb cache\r\n  delete readCallbacks[task];\r\n\r\n  if (--self.refcount === 0) {\r\n    //console.log(' ... closing', self.filePath);\r\n    fs.closeSync(self.fd);\r\n    self.fd = null;\r\n  }\r\n};\r\n\r\n\r\nmodule.exports = piper;\r\n\r\n","/home/travis/build/npmtest/node-npmtest-wordpos/node_modules/wordpos/readTest.js":"var fs = require('fs');\r\nvar len = 512;\r\nvar buffer = new Buffer(len);\r\nvar k = 1000;\r\nvar M = k * k;\r\nvar fd;\r\nvar filePath = '/dev/wordpos/node_modules/wordnet-db/dict/data.adj';\r\n\r\npos = 11 * M;\r\n\r\nfd = fs.openSync(filePath, 'r');\r\n\r\n\r\nfs.read(fd, buffer, 0, len, pos, function (err, count) {\r\n  var str = buffer.toString('hex');\r\n\r\n  console.log(err, pos, count, str)\r\n  // if (str === '' && !err) err = new Error('no data at offset ' + pos);\r\n});\r\n","/home/travis/build/npmtest/node-npmtest-wordpos/node_modules/wordpos/bench/wordpos-bench.js":"/**\r\n * wordpos-bench.js\r\n *\r\n * Copyright (c) 2012-2016 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Released under MIT license\r\n */\r\n\r\nvar Bench = require('mini-bench'),\r\n  fs = require('fs'),\r\n  _ = require('underscore')._,\r\n  WordPOS = require('../src/wordpos'),\r\n  wordpos = new WordPOS();\r\n\r\n\r\nsuite = new Bench.Suite({\r\n  type: 'fixed',\r\n  iterations: 1,\r\n  async: false,\t// important!\r\n\r\n  start: function(tests){\r\n    console.log('starting %d tests', tests.length);\r\n  },\r\n\r\n  result: function(name, stats){\r\n    var persec = 1000 / stats.elapsed\r\n      , ops = .5 + stats.iterations * persec;\r\n\r\n    console.log('  \\033[90m%s : \\033[36m%d \\033[90mops/s\\033[0m', name, ops | 0, stats);\r\n    pos && console.log(out(pos));\r\n  },\r\n\r\n  done: function(time){\r\n    console.log('looked up %d words, %d found', nwords, found);\r\n    console.log('done in %d msecs', time );\r\n  },\r\n\r\n  section: function(name, stats) {\r\n    console.log('\\033[35m%s\\033[0m',name);\r\n  }\r\n});\r\n\r\n\r\nfunction out(res){\r\n  return _(res).keys().map(function(k){\r\n    return k + ':' + res[k].length\r\n  });\r\n}\r\n\r\n\r\nvar\r\n  text = fs.readFileSync('text-512.txt', 'utf8'),\r\n  parsedText = wordpos.parse(text),\r\n  nwords = parsedText.length,\r\n  pos;\r\n\r\n\r\nfunction getPOS(next){\r\n  wordpos.getPOS(text, function(res){\r\n    pos = res;\r\n    next();\r\n  });\r\n}\r\n\r\nfunction getNouns(next){\r\n  wordpos.getNouns(text, function(res){\r\n    pos = {nouns: res};\r\n    next();\r\n  });\r\n}\r\n\r\nfunction getVerbs(next){\r\n  wordpos.getVerbs(text, function(res){\r\n    pos = {verbs: res};\r\n    next();\r\n  });\r\n}\r\n\r\nfunction getAdjectives(next){\r\n  wordpos.getAdjectives(text, function(res){\r\n    pos = {adjectives: res};\r\n    next();\r\n  });\r\n}\r\n\r\nfunction getAdverbs(next){\r\n  wordpos.getAdverbs(text, function(res){\r\n    pos = {adverbs: res};\r\n    next();\r\n  });\r\n}\r\n\r\n\r\nfunction lookup(next){\r\n  var count = nwords;\r\n  found = 0;\r\n  parsedText.forEach(function(word) {\r\n    wordpos.lookup(word, function (res) {\r\n      res.length && ++found;\r\n      if (--count === 0) next();\r\n    });\r\n  });\r\n}\r\n\r\nfunction lookupNoun(next){\r\n  var count = nwords;\r\n  found = 0;\r\n  parsedText.forEach(function(word) {\r\n    wordpos.lookupNoun(word, function (res) {\r\n      res.length && ++found;\r\n      if (--count === 0) next();\r\n    });\r\n  });\r\n}\r\n\r\nsuite.section('--512 words--', function(next){\r\n  suite.options.iterations = 1;\r\n  next();\r\n});\r\n\r\nsuite.bench('getPOS', getPOS);\r\nsuite.bench('getNouns', getNouns);\r\nsuite.bench('getVerbs', getVerbs);\r\nsuite.bench('getAdjectives', getAdjectives);\r\nsuite.bench('getAdverbs', getAdverbs);\r\nsuite.bench('lookup', lookup);\r\nsuite.bench('lookupNoun', lookupNoun);\r\n\r\nsuite.run();\r\n","/home/travis/build/npmtest/node-npmtest-wordpos/node_modules/wordpos/bin/wordpos-cli.js":"#!/usr/bin/env node\n/**\n * wordpos.js\n *\n * command-line interface to wordpos\n *\n * Usage:\n *    wordpos [options] <get|parse|def|rand|syn|exp|seek> <stdin|words*>\n *\n * Copyright (c) 2012, 2016 mooster@42at.com\n * https://github.com/moos/wordpos\n *\n * Released under MIT license\n */\n\nvar program = require('commander'),\n  _ = require('underscore')._,\n  fs = require('fs'),\n  POS = {noun:'Noun', adj:'Adjective', verb:'Verb', adv:'Adverb'},\n  POS_abbr = {noun:'n', adj:'a', verb:'v', adv:'r'},\n  version = JSON.parse(fs.readFileSync(__dirname + '/../package.json', 'utf8')).version,\n  rawCmd = '',\n  RAND_PLACEHOLDER = '__',\n  nWords;\n\nprogram\n  .version(version)\n  .usage('<command> [options] [word ... | -i <file> | <stdin>]')\n\n  .option('-n, --noun', 'get nouns only')\n  .option('-a, --adj', 'get adjectives only')\n  .option('-v, --verb', 'get verbs only')\n  .option('-r, --adv', 'get adverbs only')\n\n  .option('-c, --count', 'get counts only, used with get')\n  .option('-b, --brief', 'brief output (all on one line, no headers)')\n  .option('-f, --full', 'full results object')\n  .option('-j, --json', 'full results object as JSON string')\n  .option('-i, --file <file>', 'input file')\n  .option('-w, --withStopwords', 'include stopwords (default: stopwords are excluded)')\n  ;\n\nprogram.command('get')\n  .description('get list of words for particular POS')\n  .action(exec);\n\nprogram.command('def')\n  .description('lookup definitions (use -b for brief definition, less examples)')\n  .action(function(){\n    rawCmd = 'def';\n    _.last(arguments)._name = 'lookup';\n    exec.apply(this, arguments);\n  });\n\nprogram.command('syn')\n  .description('lookup synonyms')\n  .action(function(){\n    rawCmd = 'syn';\n    _.last(arguments)._name = 'lookup';\n    exec.apply(this, arguments);\n  });\n\nprogram.command('exp')\n  .description('lookup examples')\n  .action(function(){\n    rawCmd = 'exp';\n    _.last(arguments)._name = 'lookup';\n    exec.apply(this, arguments);\n  });\n\nprogram.command('seek')\n  .description('get record at synset offset. Must include one of POS -n, -a, -v, -r')\n  .action(function(){\n    var one = _.chain(program).pick('noun adj adv verb'.split(' ')).countBy().value().true;\n    if (!one || one > 1) {\n      console.error('Must include one and only one of -n, -a, -v, -r');\n      process.exit(-1);\n    }\n    // force full output mode\n    program.full = 1;\n    exec.apply(this, arguments);\n  });\n\nprogram.command('rand')\n  .description('get random words (starting with [word]). If first arg is a number, returns ' +\n    'that many random words. Valid options are -b, -f, -j, -s, -i.')\n  .action(function(/* arg, ..., program.command */){\n    var args = _.toArray(arguments),\n      num = args.length > 1 && Number(args[0]);\n    delete program.count;\n\n    // first arg is count?\n    if (num) {\n      args.shift();\n      program.num = num;\n    }\n    // no startsWith given, add a placeholder\n    if (args.length === 1){\n      args.unshift(RAND_PLACEHOLDER);\n    }\n    exec.apply(this, args);\n  });\n\nprogram.command('parse')\n  .description('show parsed words, deduped and less stopwords')\n  .action(exec);\n\nprogram.command('stopwords')\n  .description('show list of stopwords (valid options are -b and -j)')\n  .action(function(){\n    cmd = _.last(arguments)._name;\n    rawCmd = rawCmd || cmd;\n    var stopwords = WordPos.stopwords;\n\n    if (program.json)\n      output(stopwords);\n    else\n      console.log(stopwords.join(program.brief ? ' ' : '\\n'))\n  });\n\nvar\n  WordPos = require('../src/wordpos'),\n  util = require('util'),\n  results = {},\n  cmd = null;\n\n\nprogram.parse(process.argv);\nif (!cmd) console.log(program.helpInformation());\n\n\nfunction exec(/* args, ..., program.command */){\n  var args = _.initial(arguments);\n  cmd = _.last(arguments)._name;\n  rawCmd = rawCmd || cmd;\n\n  if (program.file) {\n    fs.readFile(program.file, 'utf8', function(err, data){\n      if (err) return console.log(err);\n      run(data);\n    });\n  } else if (args.length || cmd == 'rand'){\n    run(args.join(' '));\n  } else {\n    read_stdin(run);\n  }\n}\n\nfunction read_stdin(callback) {\n  var data = '';\n  process.stdin.resume();\n  process.stdin.setEncoding('utf8');\n  process.stdin.on('data', function (chunk) {\n    var c = chunk.charCodeAt(0);\n    if (c == 4 || c == 26) // ^c or ^d followed by \\n\n      return process.stdin.emit('end') && process.stdin.pause();\n    data += chunk;\n  });\n  process.stdin.on('end', function () {\n    callback(data);\n  });\n}\n\nfunction optToFn() {\n  var\n    map = cmd === 'seek' ? POS_abbr : POS,\n    fns = _.reject(map, function(fn, opt) { return !program[opt] });\n  if (!fns.length && cmd === 'rand') return fns = ['']; // run rand()\n  if (!fns.length) fns = _.values(map); //default to all if no POS given\n  return fns;\n}\n\nfunction run(data) {\n  var\n    opts = {stopwords: !program.withStopwords},\n    wordpos = new WordPos(opts),\n    seek = cmd === 'seek',\n    words = seek ? data.split(' ') : wordpos.parse(data),\n    fns = optToFn(),\n    plural = (cmd === 'get' ? 's':''),\n    results = {},\n    finale = _.after(plural ? fns.length : words.length * fns.length,\n        _.bind(output, null, results)),\n    collect = function(what, result, word){\n      if (word) {\t// lookup\n        results[word] = [].concat(results[word] || [], result);\n      } else {\t\t// get\n        results[what] = result;\n      }\n      finale();\n    };\n\n  nWords = words.length;\n  if (cmd == 'parse') return output({words: words});\n\n  // loop over desired POS\n  _(fns).each(function(fn){\n    var method = cmd + fn + plural,\n      cb = _.bind(collect, null, fn);\n    if (cmd === 'get') {\n      wordpos[method](words, cb);\n    } else if (cmd === 'rand') {\n      if (words[0] === RAND_PLACEHOLDER) words[0] = '';\n      words.forEach(function(word){\n        wordpos[method]({startsWith: word, count: program.num || 1}, cb);\n      });\n    } else if (seek) {\n      words.forEach(function(offset){\n        wordpos.seek(offset, fn, function(err, result){\n          results[offset.trim()] = result;\n          finale();\n        });\n      });\n    } else {\n      words.forEach(function(word){\n        wordpos[method](word, cb);\n      });\n    }\n  });\n}\n\nfunction output(results) {\n  var str;\n  if (program.count && cmd != 'lookup') {\n    var label = program.brief ? '' : _.flatten(['#', _.values(POS), 'Parsed\\n']).join(' ');\n    str = (cmd == 'get' && (label + _.reduce(POS, function(memo, v){\n      return memo + ((results[v] && results[v].length) || 0) +\" \";\n    },''))) + nWords;\n  } else {\n    str = sprint(results);\n  }\n  console.log(str);\n}\n\nfunction sprint(results) {\n  if (program.json) {\n    return util.format('%j',results);\n  } else if (program.full) {\n    return util.inspect(results,false,10, true);\n  }\n  var sep = program.brief ? ' ' : '\\n';\n\n  switch (cmd) {\n  case 'lookup':\n    return _.reduce(results, function(memo, v, k){\n      return memo + (v.length && util.format('%s (%s)\\n%s\\n', k, rawCmd, print_def(v)) || '');\n    }, '');\n  default:\n    return _.reduce(results, function(memo, v, k){\n      var pre = program.brief ? '' : util.format('# %s %d:%s', k,  v.length, sep),\n        res = v.length ? v.join(sep) : '';\n      return memo + (v.length && util.format('%s%s%s\\n', pre, res, sep) || '');\n    }, '');\n  }\n\n  function print_def(defs) {\n    var proc = {\n      def: _.property(program.brief ? 'def' : 'gloss'),\n      syn: function(res){\n        return res.synonyms.join(', ');\n      },\n      exp: function(res) {\n        return '\"' + res.exp.join('\", \"') + '\"';\n      }\n    }[ rawCmd ];\n\n    return _.reduce(defs, function(memo, v, k){\n      return memo + util.format('  %s: %s\\n', v.pos, proc(v));\n    },'');\n  }\n}\n\n","/home/travis/build/npmtest/node-npmtest-wordpos/node_modules/wordpos/src/rand.js":"/*!\r\n * rand.js\r\n *\r\n * \t\tdefine rand() and randX() functions on wordpos\r\n *\r\n * Copyright (c) 2012-2016 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Released under MIT license\r\n */\r\n\r\nvar _ = require('underscore')._,\r\n  util = require('util'),\r\n  Trie = require('../lib/natural/trie/trie'),\r\n  IndexFile = require('./indexFile'),\r\n  KEY_LENGTH = 3;\r\n\r\n\r\n/**\r\n * factory function for randX()\r\n *\r\n * @param pos {string} - a,r,n,v\r\n * @returns {Function} - rand function bound to an index file\r\n */\r\nfunction makeRandX(pos){\r\n  return function(opts, callback, _noprofile) {\r\n    // disable profiling when isX() used internally\r\n    var profile = this.options.profile && !_noprofile,\r\n      start = profile && new Date(),\r\n      args = [],\r\n      index = this.getFilesFor(pos).index,\r\n      startsWith = opts && opts.startsWith || '',\r\n      count = opts && opts.count || 1;\r\n\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n    }\r\n\r\n    return index.rand(startsWith, count, function (record) {\r\n      args.push(record, startsWith);\r\n      profile && args.push(new Date() - start);\r\n      callback && callback.apply(null, args);\r\n    });\r\n  };\r\n}\r\n\r\n/**\r\n * rand function (bound to index)\r\n *\r\n * @param startsWith {string} - get random word(s) that start with this, or ''\r\n * @param num {number} - number of words to return\r\n * @param callback {function} - callback function, receives words array and startsWith\r\n * @returns Promise\r\n */\r\nfunction rand(startsWith, num, callback){\r\n  var self = this,\r\n    nextKey = null,\r\n    trie = this.fastIndex.trie,\r\n    key, keys;\r\n\r\n  return new Promise(function(resolve, reject) {\r\n\r\n    //console.log('-- ', startsWith, num, self.fastIndex.indexKeys.length);\r\n    if (startsWith) {\r\n      key = startsWith.slice(0, KEY_LENGTH);\r\n\r\n      /**\r\n       * if key is 'a' or 'ab' (<3 chars), search for ALL keys starting with that.\r\n       */\r\n      if (key.length < KEY_LENGTH) {\r\n\r\n        // calc trie if haven't done so yet\r\n        if (!trie) {\r\n          trie = new Trie();\r\n          trie.addStrings(self.fastIndex.indexKeys);\r\n          self.fastIndex.trie = trie;\r\n          //console.log(' +++ Trie calc ');\r\n        }\r\n\r\n        try {\r\n          // trie throws if not found!!!!!\r\n          keys = trie.keysWithPrefix(startsWith);\r\n        } catch (e) {\r\n          keys = [];\r\n        }\r\n\r\n        // read all keys then select random word.\r\n        // May be large disk read!\r\n        key = keys[0];\r\n        nextKey = _.last(keys);\r\n      }\r\n\r\n      if (!key || !(key in self.fastIndex.offsets))  {\r\n        callback && callback([], startsWith);\r\n        resolve([]);\r\n      }\r\n\r\n    } else {\r\n      // no startWith given - random select among keys\r\n      keys = _.sample(self.fastIndex.indexKeys, num);\r\n\r\n      // if num > 1, run each key independently and collect results\r\n      if (num > 1) {\r\n        var results = [], ii = 0;\r\n        _(keys).each(function (startsWith) {\r\n          self.rand(startsWith, 1, function (result) {\r\n            results.push(result[0]);\r\n            if (++ii == num) {\r\n              callback && callback(results, '');\r\n              resolve(results);\r\n            }\r\n          });\r\n        });\r\n        return;\r\n      }\r\n      key = keys;\r\n    }\r\n\r\n    // prepare the piper\r\n    var args = [key, nextKey, self],\r\n      task = 'rand:' + key + nextKey,\r\n      context = [startsWith, num, callback]; // last arg MUST be callback\r\n\r\n    // pay the piper\r\n    self.piper(task, IndexFile.readIndexBetweenKeys, args, context, collector);\r\n\r\n    function collector(key, nextKey, index, startsWith, num, callback, buffer) {\r\n      var lines = buffer.toString().split('\\n'),\r\n        matches = lines.map(function (line) {\r\n          return line.substring(0, line.indexOf(' '));\r\n        });\r\n      //console.log(' got lines for key ', key, lines.length);\r\n\r\n      // we got bunch of matches for key - now search within for startsWith\r\n      if (startsWith !== key) {\r\n        // binary search for startsWith within set of matches\r\n        var ind = _.sortedIndex(matches, startsWith);\r\n        if (ind >= lines.length || matches[ind].indexOf(startsWith) === -1) {\r\n          callback && callback([], startsWith);\r\n          resolve([]);\r\n          return;\r\n        }\r\n\r\n        var trie = new Trie();\r\n        trie.addStrings(matches);\r\n        //console.log('Trie > ', trie.matchesWithPrefix( startsWith ));\r\n        matches = trie.keysWithPrefix(startsWith);\r\n      }\r\n\r\n      var words = _.sample(matches, num);\r\n      callback && callback(words, startsWith);\r\n      resolve(words);\r\n    }\r\n\r\n  }); // Promise\r\n}\r\n\r\n// relative weight of each POS word count (DB 3.1 numbers)\r\nvar POS_factor = {\r\n  Noun: 26,\r\n  Verb: 3,\r\n  Adjective: 5,\r\n  Adverb: 1,\r\n  Total: 37\r\n};\r\n\r\n/**\r\n * rand() - for all Index files\r\n * @returns Promise\r\n */\r\nfunction randAll(opts, callback) {\r\n  var\r\n    profile = this.options.profile,\r\n    start = profile && new Date(),\r\n    results = [],\r\n    startsWith = opts && opts.startsWith || '',\r\n    count = opts && opts.count || 1,\r\n    args = [null, startsWith],\r\n    parts = 'Noun Verb Adjective Adverb'.split(' '),\r\n    self = this;\r\n\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n  } else {\r\n    opts = _.clone(opts);\r\n  }\r\n\r\n\r\n  return new Promise(function(resolve, reject) {\r\n    // select at random a POS to look at\r\n    var doParts = _.sample(parts, parts.length);\r\n    tryPart();\r\n\r\n    function tryPart() {\r\n      var part = doParts.pop(),\r\n        rand = 'rand' + part,\r\n        factor = POS_factor[part],\r\n        weight = factor / POS_factor.Total;\r\n\r\n      // pick count according to relative weight\r\n      opts.count = Math.ceil(count * weight * 1.1); // guard against dupes\r\n      self[rand](opts, partCallback);\r\n    }\r\n\r\n    function partCallback(result) {\r\n      if (result) {\r\n        results = _.uniq(results.concat(result));  // make sure it's unique!\r\n      }\r\n\r\n      if (results.length < count && doParts.length) {\r\n        return tryPart();\r\n      }\r\n\r\n      // final random and trim excess\r\n      results = _.sample(results, count);\r\n      done();\r\n    }\r\n\r\n    function done() {\r\n      profile && (args.push(new Date() - start));\r\n      args[0] = results;\r\n      callback && callback.apply(null, args);\r\n      resolve(results);\r\n    }\r\n\r\n  }); // Promise\r\n}\r\n\r\n/**\r\n * bind rand() to index\r\n *\r\n * @param index {object} - the IndexFile instance\r\n * @returns {function} - bound rand function for index\r\n */\r\nfunction randomify(index){\r\n  if (!index.fastIndex) throw 'rand requires fastIndex';\r\n  return _.bind(rand, index);\r\n}\r\n\r\n\r\n\r\nmodule.exports = {\r\n\r\n  init: function(wordposProto) {\r\n    wordposProto.nounIndex.rand = randomify(wordposProto.nounIndex);\r\n    wordposProto.verbIndex.rand = randomify(wordposProto.verbIndex);\r\n    wordposProto.adjIndex.rand = randomify(wordposProto.adjIndex);\r\n    wordposProto.advIndex.rand = randomify(wordposProto.advIndex);\r\n\r\n    /**\r\n     * define rand()\r\n     */\r\n    wordposProto.rand = randAll;\r\n\r\n    /**\r\n     * define randX()\r\n     */\r\n    wordposProto.randAdjective = makeRandX('a');\r\n    wordposProto.randAdverb = makeRandX('r');\r\n    wordposProto.randNoun = makeRandX('n');\r\n    wordposProto.randVerb = makeRandX('v');\r\n  }\r\n};\r\n\r\n","/home/travis/build/npmtest/node-npmtest-wordpos/node_modules/wordpos/lib/natural/trie/trie.js":"/*\nCopyright (c) 2014 Ken Koch\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/** \n * The basis of the TRIE structure.\n **/\nfunction Trie(caseSensitive) {\n\tthis.dictionary = {};\n\tthis.$ = false;\n\n\tif(typeof caseSensitive === \"undefined\") {\n\t\tcaseSensitive = true;\n\t}\n\n\tthis.cs = caseSensitive;\n}\n\n/**\n * Add a single string to the TRIE, returns true if the word was already in the \n * trie.\n **/\nTrie.prototype.addString = function(string) {\n\tif(this.cs === false) {\n\t\tstring = string.toLowerCase();\n\t}\n\n\t// If the string has only one letter, mark this as a word.\n\tif(string.length === 0) {\n\t\tvar wasWord = this.$;\n\t\tthis.$ = true;\n\t\treturn wasWord;\n\t}\n\n\t// Make sure theres a Trie node in our dictionary\n\tvar next = this.dictionary[string[0]];\n\n\tif(!next) {\n\t\tthis.dictionary[string[0]] = new Trie(this.cs);\n\t\tnext = this.dictionary[string[0]];\n\t}\n\n\t// Continue adding the string\n\treturn next.addString(string.substring(1));\n};\n\n/**\n * Add multiple strings to the TRIE\n **/\nTrie.prototype.addStrings = function(list) {\n\tfor(var i in list) {\n\t\tthis.addString(list[i]);\n\t}\n};\n\n/**\n * A function to search the TRIE and return an array of\n * words which have same prefix <prefix>\n * for example if we had the following words in our database:\n * a, ab, bc, cd, abc, abd\n * and we search the string: a\n * we will get :\n * [a, ab, abc, abd]\n **/\nTrie.prototype.keysWithPrefix = function(prefix) {\n    if(this.caseSensitive === false) {\n        prefix = prefix.toLowerCase();\n    }\n\n    function isEmpty (object) {\n        for (var key in object) if (object.hasOwnProperty(key)) return false;\n        return true;\n    }\n\n    function get (node, word) {\n        if(!node) return null;\n        if(word.length == 0) return node;\n        return get(node.dictionary[word[0]], word.substring(1));\n    }\n\n    function recurse ( node, stringAgg, resultsAgg) {\n        if (!node) return;\n\n        // Check if this is a word\n        if (node.$) {\n            resultsAgg.push(stringAgg);\n        }\n\n        if (isEmpty(node.dictionary)) {\n            return ;\n        }\n\n        for (var c in node.dictionary) {\n            recurse (node.dictionary[c],stringAgg + c, resultsAgg);\n        }\n    }\n\n    var results = [];\n    recurse (get(this, prefix), prefix, results);\n    return results;\n};\n\n/** \n * A function to search the given string and return true if it lands\n * on on a word. Essentially testing if the word exists in the database.\n **/\nTrie.prototype.contains = function(string) {\n\tif(this.cs === false) {\n\t\tstring = string.toLowerCase();\n\t}\n\n\tif(string.length === 0) {\n\t\treturn this.$;\n\t}\n\n\t// Otherwise, we need to continue searching\n\tvar firstLetter = string[0];\n\tvar next = this.dictionary[firstLetter];\t\t\n\n\t// If we don't have a node, this isn't a word\n\tif(!next) {\n\t\treturn false;\n\t}\n\n\t// Otherwise continue the search at the next node\n\treturn next.contains(string.substring(1));\n}\n\n/**\n * A function to search the TRIE and return an array of words which were encountered along the way.\n * This will only return words with full prefix matches.\n * for example if we had the following words in our database:\n * a, ab, bc, cd, abc\n * and we searched the string: abcd\n * we would get only:\n * [a, ab, abc]\n **/\nTrie.prototype.findMatchesOnPath = function(search) {\n\tif(this.cs === false) {\n\t\tsearch = search.toLowerCase();\n\t}\n\n\tfunction recurse(node, search, stringAgg, resultsAgg) {\n\t\t// Check if this is a word.\n\t\tif(node.$) {\n\t\t\tresultsAgg.push(stringAgg);\n\t\t}\n\n\t\t// Check if the have completed the seearch\n\t\tif(search.length === 0) {\n\t\t\treturn resultsAgg;\n\t\t}\n\n\t\t// Otherwise, continue searching\n\t\tvar next = node.dictionary[search[0]];\n\t\tif(!next) {\n\t\t\treturn resultsAgg;\n\t\t}\n\t\treturn recurse(next, search.substring(1), stringAgg + search[0], resultsAgg);\n\t};\n\n\treturn recurse(this, search, \"\", []);\n};\n\n/**\n * Returns the longest match and the remaining part that could not be matched.\n * inspired by [NLTK containers.trie.find_prefix](http://nltk.googlecode.com/svn-/trunk/doc/api/nltk.containers.Trie-class.html).\n **/\nTrie.prototype.findPrefix = function(search) {\n\tif(this.cs === false) {\n\t\tsearch = search.toLowerCase();\n\t}\n\t\n\tfunction recurse(node, search, stringAgg, lastWord) {\n\t\t// Check if this is a word\n\t\tif(node.$) {\n\t\t\tlastWord = stringAgg;\n\t\t}\n\n\t\t// Check if we have no more to search\n\t\tif(search.length === 0) {\n\t\t\treturn [lastWord, search];\n\t\t}\n\n\t\t// Continue searching\n\t\tvar next = node.dictionary[search[0]];\n\t\tif(!next) {\n\t\t\treturn [lastWord, search];\n\t\t}\n\t\treturn recurse(next, search.substring(1), stringAgg + search[0], lastWord);\n\t};\n\n\treturn recurse(this, search, \"\", null);\n};\n\n/**\n * Computes the number of actual nodes from this node to the end.\n * Note: This involves traversing the entire structure and may not be\n * good for frequent use.\n **/\nTrie.prototype.getSize = function() { \n\tvar total = 1;\n\tfor(var c in this.dictionary) {\n\t\ttotal += this.dictionary[c].getSize();\n\t}\n\treturn total;\n};\n\n/**\n * EXPORT THE TRIE\n **/\nmodule.exports = Trie;\n\n","/home/travis/build/npmtest/node-npmtest-wordpos/node_modules/wordpos/tools/buffered-reader.js":"/**\r\n * @name BufferedReader.\r\n * @description Fully configurable buffered reader for node.js.\r\n *\r\n * @author Gabriel Llamas\r\n * @created 10/04/2012\r\n * @modified 01/05/2012\r\n * @version 0.2.0\r\n *\r\n * Forked: https://github.com/moos/Node-BufferedReader\r\n */\r\n\"use strict\";\r\n\r\nvar EVENTS = require (\"events\");\r\nvar FS = require (\"fs\");\r\n\r\nvar BUFFER_SIZE = 16384;\r\n\r\nvar INVALID_BUFFER_SIZE = \"The buffer size must be greater than 0.\";\r\nvar INVALID_START_OFFSET = \"The start offset must be greater than or equals to 0.\";\r\nvar INVALID_END_OFFSET = \"The end offset must be greater than or equals to 0.\";\r\nvar INVALID_RANGE_OFFSET = \"The end offset must be greater than or equals to the start offset.\";\r\nvar INVALID_BYTES_RANGE_ERROR = \"The number of bytes to read must be greater than 0.\";\r\nvar INVALID_SEEK_OFFSET = \"The offset must be greater than or equals to 0.\";\r\nvar NO_FILE_ERROR = \"The source is not a file.\";\r\n\r\nvar BufferedReader = function (fileName, settings){\r\n  EVENTS.EventEmitter.call (this);\r\n\r\n  settings = settings || {};\r\n\r\n  if (settings.bufferSize === 0) settings.bufferSize = -1;\r\n  this._settings = {\r\n    bufferSize: settings.bufferSize || BUFFER_SIZE,\r\n    encoding: settings.encoding || null,\r\n    start: settings.start || 0,\r\n    end: settings.end\r\n  };\r\n\r\n  if (this._settings.bufferSize < 1) throw new Error (INVALID_BUFFER_SIZE);\r\n  if (this._settings.start < 0) throw new Error (INVALID_START_OFFSET);\r\n  if (this._settings.end < 0) throw new Error (INVALID_END_OFFSET);\r\n  if (this._settings.end < this._settings.start) throw new Error (INVALID_RANGE_OFFSET);\r\n\r\n  this._fileName = fileName;\r\n  this._fd = null;\r\n  this._buffer = null;\r\n\r\n  this._fileOffset = this._settings.start;\r\n  this._bufferOffset = 0;\r\n  this._dataOffset = 0;\r\n  this._realOffset = this._settings.start;\r\n\r\n  this._fileSize = null;\r\n  this._initialized = false;\r\n  this._interrupted = false;\r\n  this._isEOF = false;\r\n  this._noMoreBuffers = false;\r\n  this._needRead = false;\r\n};\r\n\r\nBufferedReader.prototype = Object.create (EVENTS.EventEmitter.prototype);\r\nBufferedReader.prototype.constructor = BufferedReader;\r\n\r\nBufferedReader.prototype.interrupt = function (){\r\n  this._interrupted = true;\r\n};\r\n\r\nBufferedReader.prototype.read = function (){\r\n  var stream = FS.createReadStream (this._fileName, this._settings);\r\n\r\n  // node version change: stream.encoding no longer exposed\r\n  stream.encoding = this._settings.encoding;\r\n\r\n  var lastChunk;\r\n  var buffer;\r\n  var me = this;\r\n  var lineOffset = 0,\r\n    lineCount = 0,\r\n    byteOffset = 0;\r\n\r\n  var onChar = this.listeners (\"character\").length !== 0,\r\n    onLine = this.listeners (\"line\").length !== 0,\r\n    onByte = this.listeners (\"byte\").length !== 0,\r\n    loop = onChar || onLine || onByte;\r\n\r\n  stream.on (\"data\", function (data){\r\n    buffer = data;\r\n    var offset = 0;\r\n    var chunk;\r\n    var character;\r\n    var len = data.length;\r\n\r\n    if (loop){\r\n      for (var i=0; i<len; i++){\r\n        if (me._interrupted) break;\r\n\r\n        character = data[i];\r\n        if (stream.encoding){\r\n          onChar && me.emit (\"character\", character === \"\\r\" ? \"\\n\" : character, byteOffset + i);\r\n        }else{\r\n          onByte && me.emit (\"byte\", character, byteOffset + i);\r\n          continue;\r\n        }\r\n\r\n        if (!onLine) continue;\r\n        if (character === \"\\n\" || character === \"\\r\"){\r\n          chunk = data.slice (offset, i);\r\n\r\n          if (lastChunk){\r\n            chunk = lastChunk.concat (chunk);\r\n          }\r\n\r\n          if (i + 1 !== len && character === \"\\r\" && data[i + 1] === \"\\n\"){\r\n            i++;\r\n          }\r\n\r\n          me.emit (\"line\", chunk, lineOffset + offset, ++lineCount);\r\n          offset = i + 1;\r\n          if (lastChunk){\r\n              lineOffset += lastChunk.length;\r\n              lastChunk = null;\r\n            }\r\n        }\r\n      }\r\n\r\n      if (stream.encoding && offset !== len){\r\n        var s = offset === 0 ? data : data.slice (offset);\r\n        lastChunk = lastChunk ? lastChunk.concat (s) : s;\r\n      }\r\n      lineOffset += offset;\r\n    }\r\n\r\n    me.emit (\"buffer\", data, byteOffset);\r\n    if (me._interrupted){\r\n      me._interrupted = false;\r\n      stream.destroy ();\r\n      me.emit (\"end\");\r\n    }\r\n    byteOffset += len;\r\n\r\n  });\r\n\r\n  stream.on (\"end\", function (){\r\n    me._interrupted = false;\r\n    if (loop && lastChunk){\r\n      me.emit (\"line\", lastChunk);\r\n    }\r\n    me.emit (\"end\");\r\n  });\r\n\r\n  stream.on (\"error\", function (error){\r\n    me._interrupted = false;\r\n    me.emit (\"error\", error);\r\n  });\r\n};\r\n\r\nBufferedReader.prototype._init = function (cb){\r\n  var me = this;\r\n  FS.stat (this._fileName, function (error, stats){\r\n    if (error) return cb (error);\r\n    if (stats.isFile ()){\r\n      if (me._settings.start >= stats.size){\r\n        me._isEOF = true;\r\n        return cb (null);\r\n      }\r\n      if (!me._settings.end && me._settings.end !== 0){\r\n        me._settings.end = stats.size;\r\n      }\r\n      if (me._settings.end >= stats.size){\r\n        me._settings.end = stats.size - 1;\r\n      }\r\n      me._fileSize = stats.size;\r\n      cb (null);\r\n    }else{\r\n      cb (new Error (NO_FILE_ERROR));\r\n    }\r\n  });\r\n};\r\n\r\nBufferedReader.prototype._read = function (cb){\r\n  var me = this;\r\n  var size = this._settings.bufferSize;\r\n  FS.read (this._fd, this._buffer, 0, size, this._fileOffset, function (error, bytesRead){\r\n    if (error) return cb (error);\r\n\r\n    me._fileOffset += bytesRead;\r\n    if (me._fileOffset === me._fileSize){\r\n      me._noMoreBuffers = true;\r\n    }\r\n    if (bytesRead < size){\r\n      me._buffer = me._buffer.slice (0, bytesRead);\r\n    }\r\n    cb (null);\r\n  });\r\n};\r\n\r\nBufferedReader.prototype._readBytes = function (bytes, cb){\r\n  if (this._needRead){\r\n    this._needRead = false;\r\n    var me = this;\r\n    this._read (function (error){\r\n      if (error) return cb (error, null, -1);\r\n      me._readBytes (bytes, cb);\r\n    });\r\n    return;\r\n  }\r\n\r\n  var fill = function (){\r\n    var endData = bytes - me._dataOffset;\r\n    var endBuffer = me._buffer.length - me._bufferOffset;\r\n    var end = endBuffer <= endData ? endBuffer : endData;\r\n\r\n    me._buffer.copy (data, me._dataOffset, me._bufferOffset, me._bufferOffset + end);\r\n    me._bufferOffset += end;\r\n    me._realOffset += end;\r\n\r\n    if (me._bufferOffset === me._buffer.length){\r\n      me._bufferOffset = 0;\r\n      me._needRead = true;\r\n    }\r\n    me._dataOffset += end;\r\n\r\n    if (me._dataOffset === bytes){\r\n      me._dataOffset = 0;\r\n      me._isEOF = me._noMoreBuffers;\r\n      cb (null, data, bytes);\r\n    }else{\r\n      if (me._noMoreBuffers){\r\n        me._isEOF = true;\r\n        end = me._dataOffset;\r\n        me._dataOffset = 0;\r\n        cb (null, data.slice (0, end), end);\r\n      }else{\r\n        me._needRead = false;\r\n        me._read (function (error){\r\n          if (error) return cb (error, null, -1);\r\n\r\n          fill ();\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  var me = this;\r\n\r\n  var max = me._settings.end - me._realOffset + 1;\r\n  bytes = max < bytes ? max : bytes;\r\n  if (bytes === 0) return cb (null, null, 0);\r\n\r\n  var data = new Buffer (bytes);\r\n  var len = me._buffer.length;\r\n\r\n  if (bytes <= len){\r\n    var end = me._bufferOffset + bytes;\r\n\r\n    if (end <= len){\r\n      me._buffer.copy (data, 0, me._bufferOffset, end);\r\n      me._bufferOffset = end;\r\n      me._realOffset += bytes;\r\n      cb (null, data, bytes);\r\n    }else{\r\n      var last = len - me._bufferOffset;\r\n      me._realOffset += last;\r\n\r\n      if (last !== 0){\r\n        me._buffer.copy (data, 0, me._bufferOffset, me._bufferOffset + last);\r\n      }\r\n      if (me._noMoreBuffers){\r\n        me._isEOF = true;\r\n        return cb (null, data.slice (0, last), last);\r\n      }\r\n\r\n      me._read (function (error){\r\n        if (error) return cb (error, null, -1);\r\n\r\n        len = me._buffer.length;\r\n        var remaining = bytes - last;\r\n        if (len <= remaining){\r\n          me._realOffset += len;\r\n          me._isEOF = true;\r\n          me._buffer.copy (data, last, 0, len);\r\n          var lastChunk = last + len;\r\n          cb (null, data.slice (0, lastChunk), lastChunk);\r\n        }else{\r\n          me._realOffset += remaining;\r\n          me._bufferOffset = remaining;\r\n          me._buffer.copy (data, last, 0, me._bufferOffset);\r\n          cb (null, data, bytes);\r\n        }\r\n      });\r\n    }\r\n  }else{\r\n    fill ();\r\n  }\r\n};\r\n\r\nBufferedReader.prototype.close = function (cb){\r\n  if (cb) cb = cb.bind (this);\r\n  if (!this._fd){\r\n    if (cb) cb (null);\r\n    return;\r\n  }\r\n\r\n  var me = this;\r\n  FS.close (this._fd, function (error){\r\n    me._fd = null;\r\n    me._buffer = null;\r\n    if (cb) cb (error);\r\n  });\r\n};\r\n\r\nBufferedReader.prototype.readBytes = function (bytes, cb){\r\n  cb = cb.bind (this);\r\n  if (bytes < 1 || this._isEOF) return cb (null, null, 0);\r\n\r\n  var open = function (){\r\n    if (me._isEOF) return cb (null, null, 0);\r\n    FS.open (me._fileName, \"r\", function (error, fd){\r\n      if (error) return cb (error, null, -1);\r\n\r\n      me._fd = fd;\r\n      me._buffer = new Buffer (me._settings.bufferSize);\r\n      me._read (function (error){\r\n        if (error) return cb (error, null, -1);\r\n        me._readBytes (bytes, cb);\r\n      });\r\n    });\r\n  };\r\n\r\n  var me = this;\r\n  if (!this._initialized){\r\n    this._init (function (error){\r\n      if (error) return cb (error, null);\r\n      me._initialized = true;\r\n      open ();\r\n    });\r\n  }else{\r\n    if (!this._fd) return open ();\r\n    this._readBytes (bytes, cb);\r\n  }\r\n};\r\n\r\nBufferedReader.prototype.seek = function (offset, cb){\r\n  cb = cb.bind (this);\r\n  if (offset < 0) return cb (new Error (INVALID_SEEK_OFFSET));\r\n\r\n  var seek = function (){\r\n    offset += me._settings.start;\r\n    if (offset >= me._settings.end + 1){\r\n      me._isEOF = true;\r\n    }else{\r\n      me._isEOF = false;\r\n      var start = me._fileOffset - (me._buffer ? me._buffer.length : 0);\r\n      if (offset >= start && offset < me._fileOffset){\r\n        me._bufferOffset = offset - start;\r\n        me._realOffset = offset;\r\n      }else{\r\n        me._needRead = me._fd ? true : false;\r\n        me._noMoreBuffers = false;\r\n        me._fileOffset = offset;\r\n        me._bufferOffset = 0;\r\n        me._realOffset = offset;\r\n      }\r\n    }\r\n    cb (null);\r\n  };\r\n\r\n  var me = this;\r\n  if (!this._initialized){\r\n    this._init (function (error){\r\n      if (error) return cb (error, null);\r\n      me._initialized = true;\r\n      seek ();\r\n    });\r\n  }else{\r\n    seek ();\r\n  }\r\n};\r\n\r\nBufferedReader.prototype.skip = function (bytes, cb){\r\n  cb = cb.bind (this);\r\n  if (bytes < 1 || this._isEOF) return cb (null, 0);\r\n\r\n  var skip = function (){\r\n    var remaining = me._settings.end - me._realOffset + 1;\r\n    bytes = bytes <= remaining ? bytes : remaining;\r\n    me.seek (me._realOffset - me._settings.start + bytes, function (){\r\n      cb (null, bytes);\r\n    });\r\n  };\r\n\r\n  var me = this;\r\n  if (!this._initialized){\r\n    this._init (function (error){\r\n      if (error) return cb (error, null);\r\n      me._initialized = true;\r\n      skip ();\r\n    });\r\n  }else{\r\n    skip ();\r\n  }\r\n};\r\n\r\nmodule.exports = BufferedReader;","/home/travis/build/npmtest/node-npmtest-wordpos/node_modules/wordpos/tools/stat.js":"/**\r\n * stat.js\r\n *\r\n *     generate fast index for WordNet index files\r\n *\r\n * Usage:\r\n *    node stat [--no-stats] index.adv ...\r\n *\r\n * --no-stats prevents writing bucket size statistics to file.\r\n *\r\n * Fast index is based on buckets keyed off first THREE characters in the index word,\r\n * eg, 'awesome' goes into bucket 'awe'.\r\n *\r\n * Format of the fast index JSON object:\r\n *  {\r\n *   \"firstKey\":\".22\",\t\t\t\t// first key value\r\n *   \"keyLength\":3,\t\t\t\t\t// #characters in key\r\n *   \"version\":\"3.0\",\t\t\t\t// WNdb version\r\n *   \"name\":\"index.adj\",\t\t\t// index file name\r\n *   \"stats\":{\r\n *   \t\"buckets\":2326,\t\t\t\t// # of buckets\r\n *   \t\"words\":21479,\t\t\t\t// total # words\r\n *   \t\"biggest\":310,\t\t\t\t// #words in biggest bucket\r\n *   \t\"avg\":\"9.23\",\t\t\t\t// average #words per bucket\r\n *   \t\"median\":3\t\t\t\t\t// median #words per bucket\r\n *     },\r\n *   \"offsets\":{\r\n *     \"100\":[2271,\"101\"],\t\t\t// \"100\" is the key,\r\n *     \t\t\t\t\t\t\t\t// value=[byte offset in index file, next key]\r\n *      ...\r\n *    }\r\n *  }\r\n *\r\n *  To lookup a word:\r\n *\r\n *  find key (first <keyLength> chars of word)\r\n *  look it up in <offsets> O(1)\r\n *  if it exists\r\n *  \tget offset of key and offset of next key\r\n *      read index file between the two offsets\r\n *  \tbinary search read data O(log avg)\r\n *\r\n * Copyright (c) 2012-2016 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Released under MIT license\r\n */\r\nvar\r\n  WNdb = require('../src/wordpos').WNdb,\r\n  util = require('util'),\r\n  BufferedReader = require ('./buffered-reader'),\r\n  _ = require('underscore')._,\r\n  fs = require('fs'),\r\n  path = require('path'),\r\n  KEY_LENGTH = 3,\r\n  stats = true,\r\n  eofKey = '_EOF_'; // should be unique\r\n\r\nconsole.log('DB folder: ', WNdb.path);\r\nif (process.argv.length < 3) {\r\n  console.log('#Usage:\\nnode stat index.adv ...');\r\n  process.exit(1);\r\n}\r\n\r\n_(process.argv.slice(2)).filter(function(arg){\r\n  // disable writing stats file\r\n  if (arg == '--no-stats') {\r\n    stats = false;\r\n    return false;\r\n  }\r\n  return true;\r\n}).forEach(function(basename){\r\n\r\n  var indexFile = path.join(WNdb.path, basename),\r\n    jsonFile = path.join(WNdb.path, 'fast-' + basename + '.json'),\r\n    countFile = 'fast-' + basename + '.tsv',\r\n    endOffset = fs.statSync(indexFile).size,\r\n    buckets = {},\r\n    lastKey = null,\r\n    offsets = {},\r\n    firstKey = null;\r\n\r\n  new BufferedReader (indexFile, {encoding: \"utf8\"})\r\n    .on (\"error\", function (error){\r\n      console.log (\"error: %s\", indexFile, error);\r\n    })\r\n    .on (\"line\", function (line, offset){\r\n      // skip license info\r\n      if (line[0] == ' ') return;\r\n\r\n      // if (++i > 225) return this.interrupt();\r\n      var key = line.substring(0, Math.min(line.indexOf(' '), KEY_LENGTH));\r\n      if (firstKey === null) firstKey = key;\r\n\r\n      if (key in buckets) {\r\n        ++buckets[key];\r\n        return;\r\n      }\r\n\r\n      buckets[key] = 1;\r\n      offsets[key] = [offset];\r\n      (lastKey !== null) && offsets[lastKey].push(key);\t// current key is the 'next key' for the previous key\r\n      lastKey = key;\r\n    })\r\n    .on (\"end\", function (){\r\n\r\n      // add EOF offset\r\n      offsets[lastKey].push(eofKey);\r\n      offsets[eofKey] = [endOffset, null];\r\n\r\n      var size = _.size(buckets),\r\n        sum = _.reduce(buckets, function(memo, num){ return memo + num; }, 0),\r\n        sorted = _.sortBy(buckets, function(val){ return val }),\r\n        median = sorted[Math.floor(size/2)],\r\n        max =  sorted[sorted.length-1], // _.max(buckets),\r\n        maxkey = _.reduce(buckets, function(memo, val, key){ return memo + (val == max ? key :  '') }, ''),\r\n        avg = (sum/size).toFixed(2),\r\n        info = util.format('buckets %d, max %d at %s, sum %d, avg %d, median %d', size, max, maxkey, sum, avg, median);\r\n\r\n      console.log(basename, info);\r\n\r\n      if (stats) {\r\n        // distribution in groups of 10\r\n        var grouped = _.groupBy(buckets, function(num){ return 1 + 10*(Math.floor((num-1)/10) ) });\r\n        _(grouped).each(function(arr, key, list){\r\n              list[key] = arr.length;\r\n            });\r\n        str = '';\r\n        _.each(grouped, function(value, key){ str += key+\"\\t\"+value+\"\\n\" });\r\n        fs.writeFileSync(countFile, '#'+info+'\\n'\r\n            + '#bucket_size (1-10, 11-20, etc.) \\t #buckets\\n'\r\n            + str, 'utf8');\r\n      }\r\n\r\n      // offset data\r\n      var data = {\r\n          firstKey: firstKey,\r\n          keyLength: KEY_LENGTH,\r\n          version: WNdb.version,\r\n          name: basename,\r\n          stats: {\r\n            buckets: size,\r\n            words: sum,\r\n            biggest: max,\r\n            avg: avg,\r\n            median: median\r\n          },\r\n          offsets: offsets\r\n      };\r\n\r\n      fs.writeFileSync(jsonFile, JSON.stringify(data), 'utf8');\r\n      console.log('  wrote %s\\n', jsonFile);\r\n    })\r\n    .read();\r\n});\r\n","/home/travis/build/npmtest/node-npmtest-wordpos/node_modules/wordpos/tools/validate.js":"/**\r\n * validate.js\r\n *\r\n *    read each index.<pos> file, and look up using wordpos and confirm find all words\r\n *\r\n * Usage:\r\n *    node validate index.adv\r\n *\r\n * Copyright (c) 2012-2016 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Released under MIT license\r\n */\r\nvar\r\n  WordPos = require('../src/wordpos'),\r\n  WNdb = WordPos.WNdb,\r\n  util = require('util'),\r\n  BufferedReader = require (\"../tools/buffered-reader\"),\r\n  _ = require('underscore')._,\r\n  path = require('path'),\r\n  fs = require('fs'),\r\n  results = {},\r\n  puts = _.compose(function(a){ process.stdout.write(a)}, util.format);\r\n\r\nif (process.argv.length < 3) return usage();\r\n\r\nvar basename = process.argv.slice(2).shift(),\r\n  indexFile = path.join(WNdb.path, basename);\r\n\r\nif (!fs.existsSync(indexFile)) {\r\n  console.error('Error: no such file %s', indexFile);\r\n  process.exit(10);\r\n}\r\n\r\nfunction usage() {\r\n  console.log('#Usage:\\nnode validate.js index.adv');\r\n  process.exit(1);\r\n}\r\n\r\nfunction pos(basename) {\r\n  return basename.match(/index\\.(.*)/)[1];\r\n}\r\n\r\nfunction isX(basename) {\r\n  return {noun:'isNoun', verb:'isVerb', adj:'isAdjective', adv:'isAdverb'}[pos(basename)];\r\n}\r\n\r\nvar\r\n  wordpos = new WordPos(),\r\n  bin = results[basename] = {total:0, notfound:0, notlist:[]},\r\n  isFn = wordpos[isX(basename)],\r\n  words = [],\r\n  count = 0;\r\n\r\nputs('\\nReading %s:\\n', indexFile);\r\nnew BufferedReader (indexFile, {encoding: \"utf8\", _bufferSize: 170 * 1024 })\r\n  /*\r\n   * reads 16 KB chunks by default... there's an inherent nextTick() between chunks in the underlying streaming fns.\r\n   */\r\n  .on (\"error\", function (error){\r\n    console.error(\"error: %s\", indexFile, error);\r\n  })\r\n  .on (\"line\", function (line, offset){\r\n    // skip license info\r\n    if (line[0] == ' ') return;\r\n\r\n    //if (count > 50) return this.interrupt();\r\n    var word = line.substring(0, line.indexOf(' '));\r\n    ++count;\r\n    words.push(word);\r\n  })\r\n  .on (\"end\", function (){\r\n    puts('%d words, processing...', count);\r\n    words.forEach(function(word, i) {\r\n      isFn.call(wordpos, word, callback);\r\n    });\r\n  })\r\n  .read();\r\n\r\n\r\nfunction callback(result, word) {\r\n  ++bin.total;\r\n  !result && (++bin.notfound, bin.notlist.push(word));\r\n  if (bin.total == count) done();\r\n}\r\n\r\nfunction done() {\r\n  if (bin.notfound == 0) {\r\n    console.log('OK!');\r\n    process.exit(0);\r\n  }\r\n  else {\r\n    var n = 25;\r\n    console.log('%d not found\\n%s', bin.notfound, bin.notlist.slice(0,n).join('\\n'));\r\n    (bin.notlist.length > n) && console.log(' +%d more', bin.notlist.length - n);\r\n    process.nextTick(function(){ process.exit(1) });\r\n  }\r\n}\r\n\r\n"}